# How would you optimize large batch inserts/updates in Hibernate?
  1. Enable JDBC batching **hibernate.jdbc.batch_size = 50**
  2. Manage session memory to avoid memory issues
      - session.flush() (to execute the batch)
      - session.clear() (to free the cache)
  3. Do not use **GenerationType.IDENTITY** for IDs, as it disables batching. Use GenerationType.SEQUENCE instead.

  ```
  Transaction tx = session.beginTransaction();
  int batchSize = 50;
  for (int i = 0; i < items.size(); i++) {
  session.save(items.get(i));
  
      if (i % batchSize == 0) {
          session.flush();
          session.clear(); // Detach objects to free memory
      }
  }
  
  tx.commit();
  session.close();
  ```
---

# Explain difference between entity graphs and fetch joins for optimizing queries
1. Fetch Join
    - Defined directly in JPQL/HQL using JOIN FETCH.
    - Eagerly loads related entities in the same query.
    - Simple and explicit, but hardcoded in the query.
    - Best for one-off queries where you know exactly which associations to fetch.
    Example:
    ```
      @Query("SELECT d FROM Department d JOIN FETCH d.employees WHERE d.id = :id")
      Department findDepartmentWithEmployees(@Param("id") Long id)
    ```
2. Entity Graph
    - Defined via annotations or dynamically at runtime.
    - Specifies which associations to fetch without modifying the JPQL query.
    - Reusable across multiple queries; more flexible for APIs or dynamic fetch plans.
---

# How does 2nd level caching work in Hibernate and which providers have you used?
- Second-level cache stores entities across sessions (shared at SessionFactory level).
- Reduces database hits by reusing data from memory.

## How It Works
   - Hibernate first checks the first-level cache (per session).
   - If the entity is not found, it checks the second-level cache.
   - If still not found, it queries the database.
   - The fetched entity is then stored in the second-level cache for future sessions.

## Common Cache Providers
  1. Ehcache
  2. Infinispan
  3. Hazelcast
  4. JCache

## configuration
```
    hibernate.cache.use_second_level_cache=true
    hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory
```
## example
```
    @Entity
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    public class Employee {
        @Id
        private Long id;
        private String name;
    }
```

Second-level cache allows Hibernate to reuse entities across sessions, improving performance by avoiding repeated database queries.
---

# How to handle optimistic locking failures gracefully?
- Optimistic locking = “I assume no one else changes this row while I’m editing it… but I’ll double-check before saving.” Hibernate does this using a @Version field
- Catch it and retry
    If your operation is idempotent (like updating a counter), you can also implement a retry mechanism
- Show a friendly message (UI / API layer)
    The record was updated by someone else while you were editing. Please refresh and try again.
- Event-based handling
    in microservices, emit an event when a version conflict happens, and have a compensating mechanism
    like saga
---

# How do you tune SQL queries generated by JPA for performance?
spring.jpa.show-sql=true
Kill the N+1 query problem
Use pagination
Use projections wisely
Leverage batch fetching and fetch size
Use 2nd level cache (redis)
Add proper indexes.
Avoid SELECT * from large joined tables.
Use database-specific hints via native queries if needed.
Prefer JOIN FETCH over @ManyToOne(fetch = EAGER)
---

# Difference between save(), saveOrUpdate(), and persist() in Hibernate.
## save()  — *Hibernate-specific*
- Saves a new object to the database.
- Returns the generated ID.
- Object moves from transient → persistent immediately.

## persist() — *JPA Standard*
- Saves a new object but does not return ID.
- Must be called inside a transaction.
- Object moves from transient → persistent, insert may happen at flush/commit.

## saveOrUpdate() — *Hibernate-specific*
- Saves a new object or updates an existing one.
- Useful when you are not sure if the object is new or detached.
- Object moves to persistent state, and Hibernate decides INSERT or UPDATE
---

# Explain lazy loading and how to avoid LazyInitializationException.
**Lazy Loading** → load related data only when needed.
**LazyInitializationException** → accessing lazy data outside session/transaction.
Ways to avoid:
1. FetchType.EAGER -> cons: Can impact performance if many records are fetched unnecessarily.
2. JOIN FETCH queries
---

# How does @OneToMany and @ManyToOne mapping work?
**@OneToMany** 
    One entity is related to many entities. 
    **inverse (non-owning) side**(`mappedBy = "department"`) 
    default LAZY, 
    eg: one department has many employees
**@ManyToOne** 
    Many entities are related to one entit, 
    **owning side of the relationship**, (`@JoinColumn(name = "department_id")`) 
    default EAGER, 
    eg: Many employees belong to one department

---

# How do you use pagination and sorting in Spring Data JPA?
- **PageRequest.of(page, size, sort)** → Creates a `Pageable` object for pagination and sorting.
- **page** → 0-based page index (first page = 0).
- **size** → Number of records per page.
- **sort** → Field(s) to sort by (asce/desc)
---

# Explain optimistic vs pessimistic locking in JPA.
## Optimistic Locking (no locks, check version at commit → faster, scalable.)
- Assumes **conflicts are rare**.
- Does **not lock** the database row during read.
- Uses a **@Version** field to detect conflicts.
- If someone else updates the record first → **OptimisticLockException**.
- Good for **high-concurrency systems** with mostly reads.

## Pessimistic Locking(lock row upfront → safer but slower.*)
- Assumes **conflicts are common**.
- Locks the row **immediately** when reading it (e.g., `SELECT … FOR UPDATE`).
- Other transactions must **wait** until the lock is released.
- Common lock modes: `PESSIMISTIC_READ`, `PESSIMISTIC_WRITE`.

---

# Difference between Lazy and Eager loading
  - Lazy Loading:  Data is loaded **only when it’s accessed** for the first time.  
  - Eager Loading: Data is loaded **immediately along with the parent entity.**
---

# What are N+1 query problems? How to solve them?
Problem Occurs when Hibernate executes **1 query to fetch parent entities** and then **N additional queries** (one for each parent) to fetch their child entities lazily.

**Example:**  
1 query for all doctors → N queries for each doctor’s appointments.

**Solution:**  
 - Use **`JOIN FETCH`** (JPQL) or **`@EntityGraph`** to fetch related entities in a single query, or adjust the **fetch strategy** wisely.
---

# How does Hibernate manage transactions?

## Using Spring Boot `@Transactional`
- `@Transactional` opens a transaction at the **start of the method**.
- If no exceptions occur → transaction is **committed automatically**.
- If an exception occurs → transaction is **rolled back automatically**.


## Flow Without Spring
1. Open a session -> Session session = sessionFactory.openSession()
2. Begin transaction -> session.beginTransaction();
3. Perform Operations -> save, update, delete Operations are queued in Hibernate’s first-level cache (session)
4. Flush & Commit -> session.flush(), tx.commit()
5. Rollback on exception -> tx.rollback()
---

# Entity lifecycle states (Transient, Persistent, Detached, Removed)
Hibernate entities go through **four main states** during their lifecycle:
- **Transient:** Newly created object, not associated with any Hibernate session.  
- **Persistent:** An object that is associated with a Hibernate Session and will be synchronized with the database on commit. 
- **Detached:** A persistent object whose Session has been closed, or it has been evicted from the session.  
- **Removed:** Marked for deletion; will be deleted from the database on commit/flush.
---